{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"signal-client","text":"<p>Async Python framework for building Signal bots on top of <code>signal-cli-rest-api</code>.</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>Websocket ingestion with a worker pool and backpressure controls.</li> <li>Structured logging with optional PII redaction.</li> <li>Typed context helpers for replies, reactions, attachments, and receipts.</li> <li>Resiliency primitives: rate limiting, circuit breakers, durable queues, and a DLQ.</li> <li>Prometheus metrics and optional health endpoints for operations.</li> </ul>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>Getting started \u2014 prerequisites, install, and a minimal bot.</li> <li>Examples \u2014 runnable scripts for ping, reminders, and webhook relay.</li> <li>Advanced usage \u2014 middleware, context helpers, and locking.</li> <li>Operations &amp; deployment \u2014 configuration, storage, and observability.</li> <li>Release &amp; publishing \u2014 quality gates, packaging, and docs publishing.</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Runnable samples live in <code>examples/</code> and assume your environment is configured (see Getting started).</p>"},{"location":"examples/#ping-bot","title":"Ping bot","text":"<ul> <li>File: <code>examples/ping_bot.py</code></li> <li>Behavior: replies <code>pong</code> to <code>!ping</code>.</li> <li>Run: <code>poetry run python examples/ping_bot.py</code></li> </ul>"},{"location":"examples/#reminder-bot","title":"Reminder bot","text":"<ul> <li>File: <code>examples/reminder_bot.py</code></li> <li>Behavior: schedules <code>!remind &lt;seconds&gt; &lt;message&gt;</code> and sends the reminder back to the sender.</li> <li>Run: <code>poetry run python examples/reminder_bot.py</code></li> </ul>"},{"location":"examples/#webhook-relay","title":"Webhook relay","text":"<ul> <li>File: <code>examples/webhook_relay.py</code></li> <li>Behavior: starts an HTTP server (port 8081) that relays POSTed JSON <code>{recipients, message}</code> to Signal. Defaults to sending to the configured bot number if recipients are omitted.</li> <li>Run: <code>poetry run python examples/webhook_relay.py</code>, then POST to <code>http://localhost:8081/relay</code>.</li> </ul> <p>All samples expect a running <code>signal-cli-rest-api</code> instance reachable at <code>SIGNAL_SERVICE_URL</code>/<code>SIGNAL_API_URL</code>.</p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>Build a minimal Signal bot with the async <code>signal-client</code> runtime.</p>"},{"location":"getting_started/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Signal phone number registered with <code>signal-cli</code>.</li> <li>A running <code>bbernhard/signal-cli-rest-api</code> instance (websocket + REST). The defaults assume it listens on <code>http://localhost:8080</code>.</li> <li>Environment exported for your bot:   <code>bash   export SIGNAL_PHONE_NUMBER=+15551234567   export SIGNAL_SERVICE_URL=http://localhost:8080   # websocket host   export SIGNAL_API_URL=http://localhost:8080       # REST host</code></li> </ul>"},{"location":"getting_started/#install","title":"Install","text":"<ul> <li>PyPI: <code>pip install signal-client</code></li> <li>Poetry: <code>poetry add signal_client</code></li> <li>From source: <code>poetry install</code></li> </ul>"},{"location":"getting_started/#run-your-first-bot","title":"Run your first bot","text":"<p>Create <code>ping_bot.py</code> (or use <code>examples/ping_bot.py</code>):</p> <pre><code>import asyncio\nfrom signal_client import SignalClient, command\n\n@command(\"!ping\")\nasync def ping(ctx):\n    await ctx.reply_text(\"pong\")\n\nasync def main():\n    bot = SignalClient()\n    bot.register(ping)\n    await bot.start()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Then run:</p> <pre><code>poetry run python examples/ping_bot.py\n</code></pre> <p>Send <code>!ping</code> from a contact or group that the configured number can reach; the bot replies with <code>pong</code>.</p>"},{"location":"getting_started/#next-steps","title":"Next steps","text":"<ul> <li>Try the reminder and webhook relay samples.</li> <li>Review advanced usage for middleware, attachments, and reactions.</li> <li>See operations for storage, DLQ, and observability options.</li> </ul>"},{"location":"guides/advanced_usage/","title":"Advanced Usage","text":"<p>Practical patterns for richer bots, middleware, and operations.</p>"},{"location":"guides/advanced_usage/#command-handlers-and-routing","title":"Command handlers and routing","text":"<ul> <li>Use <code>@command</code> to declare triggers. Strings are matched case-insensitively by default; pass <code>case_sensitive=True</code> or regex patterns for stricter routing.</li> <li><code>whitelisted=[\"+15551234567\"]</code> restricts who can run a command.</li> <li>Register commands on the client before calling <code>start()</code>:</li> </ul> <pre><code>from signal_client import SignalClient, command\n\nbot = SignalClient()\n\n@command(r\"^!echo\\\\s+(.+)$\", case_sensitive=False)\nasync def echo(ctx):\n    await ctx.reply_text(ctx.message.message or \"\")\n\nbot.register(echo)\n</code></pre>"},{"location":"guides/advanced_usage/#middleware","title":"Middleware","text":"<p>Wrap command execution with cross-cutting concerns such as logging, auth, or rate limiting:</p> <pre><code>from collections.abc import Awaitable, Callable\nfrom signal_client import Context, SignalClient\n\nclient = SignalClient()\n\nasync def log_middleware(ctx: Context, next_handler: Callable[[Context], Awaitable[None]]) -&gt; None:\n    print(f\"handling {ctx.message.message!r} from {ctx.message.source}\")\n    await next_handler(ctx)\n    print(\"done\")\n\nclient.use(log_middleware)\n</code></pre> <p>Middleware are invoked in the order registered and wrap the underlying command handler.</p>"},{"location":"guides/advanced_usage/#context-helpers","title":"Context helpers","text":"<p>Every command receives a <code>Context</code> with typed helpers: - Replies: <code>await ctx.reply_text(\"pong\")</code>, <code>await ctx.send_markdown(\"*hi*\")</code>, <code>await ctx.send_with_preview(url)</code>. - Attachments: <code>async with ctx.download_attachments() as files:</code> yields temporary file paths for incoming attachments. - Reactions and receipts: <code>await ctx.react(\"\ud83d\udc4d\")</code>, <code>await ctx.send_receipt(ctx.message.timestamp)</code>. - Typing indicators: <code>await ctx.show_typing()</code> / <code>await ctx.hide_typing()</code>. - Distributed locks: <code>async with ctx.lock(\"resource-id\"):</code> guards critical sections when <code>STORAGE_TYPE=redis</code> and locks are enabled.</p>"},{"location":"guides/advanced_usage/#concurrency-and-resiliency","title":"Concurrency and resiliency","text":"<ul> <li>The worker pool fans out message handling; tune with <code>WORKER_POOL_SIZE</code>, <code>WORKER_SHARD_COUNT</code>, and <code>QUEUE_SIZE</code>.</li> <li>Enable persistence with <code>DURABLE_QUEUE_ENABLED=true</code> and either SQLite (<code>STORAGE_TYPE=sqlite</code>) or Redis (<code>STORAGE_TYPE=redis</code>).</li> <li>A Dead Letter Queue backs off and retries failures (<code>DLQ_MAX_RETRIES</code>, <code>DLQ_NAME</code>).</li> <li>Rate limiter and circuit breaker settings are surfaced via configuration (<code>RATE_LIMIT</code>, <code>CIRCUIT_BREAKER_*</code>).</li> </ul>"},{"location":"guides/advanced_usage/#health-and-metrics","title":"Health and metrics","text":"<ul> <li>Start a basic health server to expose <code>/live</code>, <code>/ready</code>, and <code>/dlq</code>:   ```python   from signal_client.observability.health_server import start_health_server</li> </ul> <p>app = client.app  # after initialization   await app.initialize()   await start_health_server(app, port=8082)   <code>`` - Export Prometheus metrics with</code>signal_client.observability.metrics_server.start_metrics_server(port=8000)`.</p>"},{"location":"guides/advanced_usage/#5-request-and-response-transformation","title":"5. Request and Response Transformation","text":"<p>Beyond simple headers, you might need to fundamentally alter the JSON payload of requests or responses. This is particularly useful when integrating with APIs that have idiosyncratic data structures.</p>"},{"location":"guides/advanced_usage/#example-transforming-outgoing-request-body","title":"Example: Transforming Outgoing Request Body","text":"<pre><code>import httpx\nimport json\nfrom typing import Callable, Awaitable\n\nasync def transform_request_body(\n    request: httpx.Request,\n    call_next: Callable[[httpx.Request], Awaitable[httpx.Response]],\n) -&gt; httpx.Response:\n    if request.method == \"POST\" and request.url.path == \"/v1/messages\":\n        # Assume the API expects 'content' instead of 'message'\n        original_json = json.loads(request.content)\n        if \"message\" in original_json:\n            original_json[\"content\"] = original_json.pop(\"message\")\n            request.content = json.dumps(original_json).encode(\"utf-8\")\n            request.headers[\"Content-Length\"] = str(len(request.content))\n    response = await call_next(request)\n    return response\n\n# Use this with an event_hook for 'request'.\n</code></pre>"},{"location":"guides/advanced_usage/#example-transforming-incoming-response-body","title":"Example: Transforming Incoming Response Body","text":"<pre><code>import httpx\nimport json\nfrom typing import Callable, Awaitable\n\nasync def transform_response_body(\n    response: httpx.Response,\n    call_next: Callable[[httpx.Response], Awaitable[httpx.Response]],\n) -&gt; httpx.Response:\n    if response.request.url.path == \"/v1/users\" and response.status_code == 200:\n        # Assume the API returns 'user_data' but you want 'user'\n        original_json = response.json()\n        if \"user_data\" in original_json:\n            original_json[\"user\"] = original_json.pop(\"user_data\")\n            response._content = json.dumps(original_json).encode(\"utf-8\")\n            response.headers[\"Content-Length\"] = str(len(response._content))\n    return await call_next(response)\n\n# Note: httpx's event_hooks for responses are processed after _raise_for_status,\n# so direct modification of response._content is generally needed.\n</code></pre>"},{"location":"guides/advanced_usage/#6-advanced-asynchronous-patterns","title":"6. Advanced Asynchronous Patterns","text":"<p>Leverage Python's <code>asyncio</code> for concurrent operations when making multiple API calls.</p> <pre><code>import asyncio\nfrom signal_client.adapters.api.contacts_client import ContactsClient\nfrom signal_client.adapters.api.messages_client import MessagesClient\n\nasync def fetch_contacts_and_send_messages(base_url: str, phone_number: str):\n    contacts_client = ContactsClient(base_url=base_url)\n    messages_client = MessagesClient(base_url=base_url)\n\n    # Fetch contacts concurrently\n    contacts_task = contacts_client.get_contacts(phone_number)\n    messages_to_send = [\n        {\"recipient\": \"+1234567890\", \"message\": \"Hello!\"},\n        {\"recipient\": \"+1987654321\", \"message\": \"How are you?\"},\n    ]\n    send_message_tasks = [\n        messages_client.send(msg) for msg in messages_to_send\n    ]\n\n    results = await asyncio.gather(contacts_task, *send_message_tasks)\n\n    all_contacts = results[0]\n    sent_messages_confirmations = results[1:]\n\n    print(\"Contacts:\", all_contacts)\n    print(\"Sent Messages:\", sent_messages_confirmations)\n\n# To run:\n# asyncio.run(fetch_contacts_and_send_messages(\"https://api.signal.com\", \"+11231231234\"))\n</code></pre> <p>By mastering custom middleware and leveraging asynchronous programming, you can build highly robust, flexible, and performant applications with the Signal Client.</p>"},{"location":"guides/production_deployment/","title":"Operations &amp; Deployment","text":"<p>How to run <code>signal-client</code> in production alongside <code>signal-cli-rest-api</code>.</p>"},{"location":"guides/production_deployment/#runtime-shape","title":"Runtime shape","text":"<ul> <li>Websocket listener pulls messages from <code>signal-cli-rest-api</code> at <code>SIGNAL_SERVICE_URL</code>.</li> <li>Messages enter a backpressured queue and are processed by a worker pool.</li> <li>Failures backoff into a Dead Letter Queue (DLQ) with retries.</li> <li>API calls go through a rate limiter and circuit breaker.</li> </ul>"},{"location":"guides/production_deployment/#environment","title":"Environment","text":"<p>Use environment variables (or a <code>.env</code>) to configure the runtime:</p> <pre><code>SIGNAL_PHONE_NUMBER=+15551234567\nSIGNAL_SERVICE_URL=http://localhost:8080   # websocket host\nSIGNAL_API_URL=http://localhost:8080       # REST host\nSTORAGE_TYPE=sqlite                        # memory | sqlite | redis\nDURABLE_QUEUE_ENABLED=true                 # persist ingest queue\nDLQ_MAX_RETRIES=5\nRATE_LIMIT=50\nCIRCUIT_BREAKER_FAILURE_THRESHOLD=5\nLOG_REDACTION_ENABLED=true\n</code></pre>"},{"location":"guides/production_deployment/#storage-and-backpressure","title":"Storage and backpressure","text":"<ul> <li>Memory (default): best for local development; no durability.</li> <li>SQLite: <code>STORAGE_TYPE=sqlite</code> and optional <code>SQLITE_DATABASE=signal_client.db</code> for single-node durability.</li> <li>Redis: <code>STORAGE_TYPE=redis</code> plus <code>REDIS_HOST</code>/<code>REDIS_PORT</code> to unlock distributed locks and shared queues.</li> <li>Enable ingestion persistence with <code>DURABLE_QUEUE_ENABLED=true</code>; tune <code>QUEUE_SIZE</code> and <code>DURABLE_QUEUE_MAX_LENGTH</code> for your workload.</li> </ul>"},{"location":"guides/production_deployment/#health-and-metrics","title":"Health and metrics","text":"<ul> <li>Health endpoints: <code>HealthServer</code> exposes <code>/live</code>, <code>/ready</code>, and <code>/dlq</code> (choose a port like <code>8082</code>).</li> <li>Metrics: <code>signal_client.observability.metrics_server.start_metrics_server(port=8000)</code> publishes Prometheus metrics for websocket connectivity, queue depth, DLQ, and command latency.</li> </ul>"},{"location":"guides/production_deployment/#running-the-process","title":"Running the process","text":"<ul> <li>Package or install the project (<code>pip install signal-client</code> or <code>poetry install</code>) and run your bot entrypoint with a process manager (systemd, supervisord, Docker).</li> <li>Example service command: <code>poetry run python examples/ping_bot.py</code></li> <li>Graceful shutdown: send SIGTERM/SIGINT; the client drains the queue, stops workers, and closes the websocket and HTTP session.</li> </ul>"},{"location":"guides/production_deployment/#security-and-hardening","title":"Security and hardening","text":"<ul> <li>Do not expose <code>signal-cli-rest-api</code> publicly; place it behind a firewall or private network.</li> <li>Keep secrets (auth tokens, phone numbers) in environment or a secrets manager.</li> <li>Enable log redaction in production (<code>LOG_REDACTION_ENABLED=true</code>) to avoid leaking PII.</li> </ul>"},{"location":"guides/release/","title":"Release &amp; Publishing","text":"<p>Steps to ship a new version with confidence.</p>"},{"location":"guides/release/#quality-gates","title":"Quality gates","text":"<p>Run these before cutting a release:</p> <pre><code>poetry check\npoetry run ruff check .\npoetry run mypy src\npoetry run pytest\npoetry run mkdocs build\n</code></pre>"},{"location":"guides/release/#packaging","title":"Packaging","text":"<ul> <li>Build artifacts: <code>poetry build</code> (produces wheel + sdist under <code>dist/</code>).</li> <li>Verify locally: <code>python -m pip install dist/signal_client-&lt;version&gt;-py3-none-any.whl</code> in a clean virtualenv and run a quick example (<code>poetry run python examples/ping_bot.py</code> with your env vars set).</li> </ul>"},{"location":"guides/release/#semantic-release","title":"Semantic release","text":"<ul> <li>Conventional commits drive versioning via <code>python-semantic-release</code> (configured in <code>pyproject.toml</code>, branch: <code>main</code>).</li> <li>Typical flow:   <code>bash   poetry run semantic-release version  # bumps version + changelog   poetry run semantic-release publish  # builds and uploads to PyPI/releases</code></li> <li>Keep CI configured with the necessary PyPI credentials and GitHub token for publishing.</li> </ul>"},{"location":"guides/release/#docs-publishing","title":"Docs publishing","text":"<ul> <li>Validate site: <code>poetry run mkdocs build</code></li> <li>Publish to GitHub Pages (if configured): <code>poetry run mkdocs gh-deploy --clean</code></li> <li>The README links to https://cornellsh.github.io/signal-client/; keep it in sync after each release.</li> </ul>"}]}